package projects.spatial.trees;

import projects.spatial.kdpoint.KDPoint;
import projects.spatial.nodes.PRQuadBlackNode;
import projects.spatial.nodes.PRQuadNode;

/**
 * <p>PRQuadTree implements Point-Region (P-R) QuadTrees. Those are trie-based
 * decompositions of 2D space which, unlike {@link KDTree}s or Point QuadTrees, is not generated by the data points,
 * but is decided in advance based on decomposing a 2^n &#42; 2^n space at successively smaller powers of 2.</p>
 *
 * <p>Because PR-QuadTrees are 4-ary instead of binary trees, they can offer better search
 * efficiency than KD-Trees. On the other hand, points very close to each other can cause many recursive decompositions
 * for just two points. This can negatively impact search locally in the tree. </p>
 *
 * <p>PR-QuadTrees are also not particularly easy to generalize to other dimensions, because the fan-out of every nodes is
 * 2^d, for dimensionality d of the space that is indexed. For just 10 dimensions, we already have more than 1000 children
 * subtrees per nodes. The course staff has come around some papers with applications of oct-trees, which are extensions of PR-QuadTrees) in 3 *
 * dimensions. Beyond 3, it seems that the idea of such exponential fanout trie-based quadtrees fades.</p>
 *
 * <p><b>YOU SHOULD ***NOT*** EDIT THIS CLASS!</b> If you do, you risk <b>not passing our tests!</b> All the functionality
 * of the P-R QuadTree will be implemented by the various {@link PRQuadNode}s.</p>
 *
 * @author <a href="https://github.com/JasonFil">Jason Filippou</a>
 *
 */
public class PRQuadTree implements SpatialDictionary {


    /**
     * Our root is a {@link PRQuadNode}. If null, it is assumed to be a white nodes.
     */
    private PRQuadNode root;

    /**
     * The bucketing parameter which globally controls how many {@link KDPoint}s
     */
    private int bucketingParam;


    /**
     * n defines the area spanned by the root: 2^n &#42; 2^n, with the origin (0,0) assumed to be the bottom left corner.
     * This means that the centroid has coordinates (2^(n-1), 2^(n-1))
     */
    private int k;


    /**
     * The number of {@link KDPoint}s held by the PRQuadTree. Note that, unlike KD-Trees, in PR-QuadTrees, the
     * number of nodes is not (necessarily) equal to the number of points stored.
     */
    private int count;

    /**
     * Constructor for PRQuadTree objects.
     * @param k The exponent of 2 that defines the area assumed to be spanned by the <b>entire QuadTree</b> (i.e by its
     *          root node). Remember that, as in  class, this means that the centroid of the original quadrant
     *          would be implicitly stored at (0, 0), and when we split for the first time, the cross (+) centered
     *          in (0, 0) would define 4 centroids: The top-right corner would be at ( 2^(k-1), 2^(k-1) ), the bottom-right
     *          at ( 2^(k-1),  -2 ^(k-1)), etc. For example, if this parameter is given as 5, the top-right corner of
     *          the modeled space would have cartesian cooordinates (16, 16), the bottom-right (16, -16) and so on and so forth.
     *          This also allows for the insertion of {@link KDPoint}s with <b>negative coordinates</b>: this is completely
     *          fine. Recall the discussions that we have had in class and Piazza about {@link KDPoint}s that lie <b>exactly
     *          on the sides</b> of the quadrants that our quadtree will recursively produce!
     * @param bucketingParam The "bucketing" parameter, which controls how many {@link KDPoint}s a {@link PRQuadBlackNode}
     *                       of this tree can hold before having to split.
     * @throws RuntimeException if bucketingParam &lt; 1
     * @see #k
     * @see #bucketingParam
     */
    public PRQuadTree(int k, int bucketingParam){
        if(bucketingParam < 1)
            throw new RuntimeException("Bucketing parameter needs to be at least 1!");
        this.k = k;
        this.bucketingParam = bucketingParam;
        count = 0;
    }


    @Override
    public void insert(KDPoint p) {
        if(root == null) {  // white nodes, first point stored
            root = new PRQuadBlackNode(new KDPoint(0, 0), k, bucketingParam, p); // Initial centroid assumed at (0, 0).
            count++;
            // Notice that we are calling the second constructor of PRQuadBlackNode here!
        } else {// black or gray nodes
            if(!root.search(p)) {
                root = root.insert(p, k); // will adjust height accordingly.
                count++;
            }
        }
    }

    @Override
    public void delete(KDPoint p) {
        if(root != null) {
            if(search(p)) {
                root = root.delete(p);
                count--;
            }
        }
    }

    @Override
    public boolean search(KDPoint p) {
        /* Short-circuiting makes the following line safe,
         * but it could be harder to parse when compared to an if-else statement
         * or the use of the ternary operator. Food for thought: Do I save lines of code
         * or do I try to make my code more readable? The answer is not always straightforward.
         */
        return (root != null) && root.search(p);
    }

    @Override
    public int height() {
        return (root == null) ? -1 : root.height();
    }

    @Override
    public boolean isEmpty(){
        return (count() == 0);
    }

    @Override
    public int count() {
        return count;
    }

    /**
     * A simple accessor for the dimension parameter k of the current {@link PRQuadTree}.
     * @return The parameter k that defines the length of the {@link PRQuadTree}'s ROOT node
     *
     * @see PRQuadTree#PRQuadTree(int, int)
     * @see #root
     */
    public int getK(){
        return k;
    }

    /**
     * A simple accessor for the bucket size of the current {@link PRQuadTree}.
     * @return The bucket size of the current {@link PRQuadTree}.
     */
    public int getBucketSize(){
        return bucketingParam;
    }
}
